(* Tiger grammar *)
structure A = Absyn
structure S = Symbol

fun mkSeqExp [(x, p)] = x
  | mkSeqExp xs = A.SeqExp xs

fun mkArrayExp (A.SimpleVar (i, _), exp1, exp2, pos) = A.ArrayExp { typ = i, size = exp1, init = exp2, pos = pos }
  | mkArrayExp (_, _, _, pos) = ( ErrorMsg.error pos "Invalid array element type"
                                ; A.NilExp
                                )

type nexp = (S.symbol * A.exp * A.pos)

type tdec = { name : S.symbol
            , ty : A.ty
            , pos : A.pos}

type optty = (S.symbol * A.pos) option

type pexp = (A.exp * A.pos)
      
%%
%term EOF 
    | ID of string
    | INT of int | STRING of string 
    | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
    | LBRACE | RBRACE | DOT 
    | PLUS | MINUS | TIMES | DIVIDE
    | EQ | NEQ | LT | LE | GT | GE
    | AND | OR
    | ASSIGN
    | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
    | BREAK
    | NIL | TRUE | FALSE
    | FUNCTION | VAR | TYPE | ARRAY | UMINUS

%nonterm  program of A.exp
    | exp of A.exp | expseq of (A.exp * pos) list | explist of A.exp list 
    | boolexp of A.exp | recordexp of A.exp | recordlist of (A.symbol * A.exp * int) list
    | recordlistvalue of (A.symbol * A.exp * int) list | recordfield of (A.symbol * A.exp * int)
    | dec of A.dec | decs of A.dec list| tydec of A.dec | vardec of A.dec | fundec of A.dec
    | arithmetic of A.exp | comparison of A.exp
    | lvalue of A.var
    | functioncall of A.exp
    | ty of A.ty | tyfields of A.field list | tyfield of A.field

%keyword WHILE FOR TO DO BREAK
    LET IN END
    FUNCTION VAR TYPE ARRAY OF
    IF THEN ELSE
    NIL

%start program
%eop EOF
%noshift EOF

%nonassoc ASSIGN
%left AND OR
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS
%nonassoc EQ NEQ GT GE LT LE
%right SEMICOLON
%left DO OF
%right THEN LBRACK
%left ELSE

%pos int
%verbose
%name Tiger

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program  : exp                                                 (exp)

exp : NIL                                                      (A.NilExp)
    | INT                                                      (A.IntExp INT)   
    | arithmetic                                               (arithmetic)
    | comparison                                               (comparison)
    | STRING                                                   (A.StringExp(STRING, STRINGleft))
    | WHILE exp DO exp                                         (A.WhileExp{test = exp1, body = exp2, pos = WHILEleft})
    | BREAK                                                    (A.BreakExp BREAKleft)
    | recordexp                                                (recordexp)  
    | conditionexp                                              (conditionexp)
    | FOR ID ASSIGN exp TO exp DO exp                          (A.ForExp {var = S.symbol ID
  (* 10 *)                                                               , escape = ref true
                                                                         , lo = exp1
                                                                         , hi = exp2
                                                                         , body = exp3
                                                                         , pos = FORleft}) 
    | lvalue                                                   (A.VarExp lvalue)
    | lvalue ASSIGN exp                                        (A.AssignExp {var = lvalue, exp = exp, pos = lvalueleft})
    | LET decs IN expseq END                                   (A.LetExp {decs = decs
                                                                         ,body = A.SeqExp expseq
                                                                         ,pos = LETleft})
    | functioncall                                             (functioncall)
    | MINUS exp %prec UMINUS                                   (A.OpExp {left = A.IntExp 0
                                                                        , oper = A.MinusOp
                                                                        , right = exp
                                                                        , pos = MINUSleft})
    | LPAREN RPAREN                                            (A.SeqExp [])
    | array                                                    (array)
    | LPAREN expseq RPAREN                                     (A.SeqExp expseq)
    | boolexp                                                  (boolexp)
    
(* 19 *)
array
    :ID LBRACK exp RBRACK OF exp                               (A.ArrayExp {typ = S.symbol ID
                                                                           , size = exp1
                                                                           , init = exp2
                                                                           , pos = IDleft})

conditionexp
    : IF exp THEN exp ELSE exp                                 (A.IfExp {test = exp1
                                                                        , then' = exp2
                                                                        , else' = SOME(exp3)
                                                                        , pos = IFleft}) 
    | IF exp THEN exp                                          (A.IfExp {test = exp1
                                                                        , then' = exp2
                                                                        , else' = NONE
                                                                        , pos = IFleft}) 
                                                                        
expseq : exp                                                   ([(exp, expleft)])
       | expseq SEMICOLON exp                                  (expseq @ [(exp, expleft)])

recordexp : ID LBRACE recordlist RBRACE                        (A.RecordExp {fields = recordlist
                                                                            , typ = S.symbol ID
                                                                            , pos = IDleft})
          | ID NIL                                             (A.RecordExp {fields = []
                                                                            , typ = S.symbol ID
                                                                            , pos = IDleft})
(* 25 *)
recordlist :                                                   ([])
           | recordlistvalue                                   (recordlistvalue)

recordlistvalue : recordfield                                  ([recordfield])
                | recordlistvalue COMMA recordfield            (recordlistvalue @ [recordfield])

recordfield : ID EQ exp                                        ((S.symbol ID, exp, IDleft))

explist :                                                      ([])
        | exp                                                  ([exp])
        | explist COMMA exp                                    (explist @ [exp])
 
 (* 33 *)
lvalue : ID             %prec LBRACK                                                   (A.SimpleVar(S.symbol ID, IDleft))
       | nonID                                                  (nonID)

nonID
    : lvalue DOT ID                                             (A.FieldVar(lvalue, S.symbol ID, lvalueleft))
    | lvalue LBRACK exp RBRACK                                  (A.SubscriptVar(lvalue, exp, lvalueleft))
       

decs :                                                          ([])
     | decs dec                                                 (decs @ [dec])

dec : tydec                                                     (tydec)
    | vardec                                                    (vardec)
    | fundec                                                    (fundec)

(* 42 *)
ty : ID                                                         (A.NameTy (S.symbol ID, IDleft))
   | LBRACE tyfields RBRACE                                     (A.RecordTy tyfields)
   | ARRAY OF ID                                                (A.ArrayTy (S.symbol ID, IDleft))

tyfield : ID COLON ID                                           ({name = S.symbol ID1
                                                                 , escape = ref true
                                                                 , typ = S.symbol ID2
                                                                 , pos = ID1left})

tyfields :                                                      ([])
         | tyfield                                              ([tyfield])
         | tyfields COMMA tyfield                               (tyfields @ [tyfield]) 

tydec : TYPE ID EQ ty                                           (A.TypeDec [{name = S.symbol ID
                                                                          , ty = ty
                                                                          , pos = TYPEleft}])

vardec : VAR ID ASSIGN exp                                      (A.VarDec {name = S.symbol ID
                                                                         , escape = ref true
                                                                         , typ = NONE
                                                                         , init = exp
                                                                         , pos = VARleft})
       | VAR ID COLON ID ASSIGN exp                             (A.VarDec {name = S.symbol ID1
                                                                         , escape = ref true
                                                                         , typ = SOME (S.symbol ID2, ID2left)
                                                                         , init = exp
                                                                         , pos = VARleft})
(*  52 *)
fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp              (A.FunctionDec [{name = S.symbol ID
                                                                              , params = tyfields
                                                                              , result = NONE
                                                                              , body = exp
                                                                              , pos = FUNCTIONleft}])
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp     (A.FunctionDec [{name = S.symbol ID1
                                                                              , params = tyfields
                                                                              , result = SOME (S.symbol ID2, ID2left)
                                                                              , body = exp
                                                                              , pos = FUNCTIONleft}])
        
arithmetic : exp PLUS exp                                       (A.OpExp {left = exp1
                                                                        , oper = A.PlusOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp MINUS exp                                      (A.OpExp {left = exp1
                                                                        , oper = A.MinusOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp TIMES exp                                      (A.OpExp {left = exp1
                                                                        , oper = A.TimesOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp DIVIDE exp                                     (A.OpExp {left = exp1
                                                                        , oper = A.DivideOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
  
comparison : exp EQ exp                                         (A.OpExp {left = exp1
                                                                        , oper = A.EqOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp NEQ exp                                        (A.OpExp {left = exp1
                                                                        , oper = A.NeqOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp LT exp                                         (A.OpExp {left = exp1
                                                                        , oper = A.LtOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp LE exp                                        (A.OpExp {left = exp1
                                                                        , oper = A.LeOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp GT exp                                        (A.OpExp {left = exp1
                                                                        , oper = A.GtOp
                                                                        , right = exp2
                                                                        , pos = exp1left})
           | exp GE exp                                        (A.OpExp {left = exp1
                                                                        , oper = A.GeOp
                                                                        , right = exp2
                                                                        , pos = exp1left})

boolexp : exp AND exp                                          (A.IfExp {test = exp1
                                                                        , then' = exp2
                                                                        , else' = SOME(A.BoolExp(false))
                                                                        , pos = exp1left})
        | exp OR exp                                           (A.IfExp {test = exp1
                                                                        , then' = A.BoolExp(true)
                                                                        , else' = SOME(exp2)
                                                                        , pos = exp1left})
                                                                        
functioncall : ID LPAREN explist RPAREN                        (A.CallExp {func = S.symbol ID
                                                                          , args = explist
                                                                          , pos = IDleft})
(* 67 *)
