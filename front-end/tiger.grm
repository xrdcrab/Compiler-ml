(* Tiger grammar *)
structure A = Absyn
structure S = Symbol

fun mkSeqExp [(x, p)] = x
  | mkSeqExp xs = A.SeqExp xs

fun mkArrayExp (A.SimpleVar (i, _), exp1, exp2, pos) = A.ArrayExp { typ = i, size = exp1, init = exp2, pos = pos }
  | mkArrayExp (_, _, _, pos) = ( ErrorMsg.error pos "Invalid array element type"
                                ; A.NilExp
                                )

type nexp = (S.symbol * A.exp * A.pos)

type tdec = { name : S.symbol
            , ty : A.ty
            , pos : A.pos}

type optty = (S.symbol * A.pos) option

type pexp = (A.exp * A.pos)
      
%term EOF 
    | ID of string
    | INT of int | STRING of string 
    | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
    | LBRACE | RBRACE | DOT 
    | PLUS | MINUS | TIMES | DIVIDE
    | EQ | NEQ | LT | LE | GT | GE
    | AND | OR
    | ASSIGN
    | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
    | BREAK
    | NIL | TRUE | FALSE
    | FUNCTION | VAR | TYPE | ARRAY | UMINUS

%nonterm  program of A.exp
    | exp of A.exp | optionalexp of A.exp | explist of A.exp list
    | dec of A.dec | decs of A.dec list| tydec of A.dec | vardec of A.dec | fundec of A.dec
    | arithmetic of A.exp | comparison of A.exp
    | lvalue of A.var
    | functioncall of A.exp
    | ty of A.ty | tyfields of A.fields list


%keyword WHILE FOR TO DO BREAK
         LET IN END
         FUNCTION VAR TYPE ARRAY OF
         IF THEN ELSE
         NIL TRUE FALSE

%start program
%eop EOF
%noshift EOF

%nonassoc ASSIGN
%left UMINUS
%left TIMES DIVIDE
%left PLUS MINUS
%left AND OR
%nonassoc EQ NEQ GT GE LT LE
%right SEMICOLON
%left THEN
%left DO OF ELSE

%pos int
%verbose
%name Tiger

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program  : exp                                                 (exp)

exp : NIL                                                      (A.NilExp)
    | TRUE                                                     (A.BoolExp true)
    | FALSE                                                    (A.BoolExp false)
    | INT                                                      (A.IntExp INT)   
    | arithmetic                                               (arithmetic)
    | comparison                                               (comparison)
    | STRING                                                   (A.StringExp(STRING, STRINGleft))
    | WHILE exp DO exp                                         (A.WhileExp{test = exp1, body = exp2, pos = WHILEleft})
    | BREAK                                                    (A.BreakExp BREAKleft)   
    | IF exp THEN exp ELSE exp                                 (A.IfExp {test = exp1
                                                                        , then' = exp2
                                                                        , else' = SOME(exp3)
                                                                        , pos = IFleft}) 
    | IF exp THEN exp                                          (A.IfExp {test = exp1
                                                                        , then' = exp2
                                                                        , else' = NONE
                                                                        , pos = IFleft})
    | FOR ID ASSIGN exp TO exp DO exp                          (A.ForExp {var = S.symbol ID
                                                                         , escape = ref true
                                                                         , lo = exp1
                                                                         , hi = exp2
                                                                         , body = exp3
                                                                         , pos = FORleft}) 
    | lvalue                                                   (A.VarExp lvalue)
    | lvalue ASSIGN exp                                        (A.AssignExp {var = lvalue, exp = exp, pos = lvalueleft})
    | LET decs IN optionalexp END                              (A.LetExp {decs = rev decs
                                                                         ,body = optionalexp
                                                                         ,pos = LETleft})
    | functioncall                                             (functioncall)
    | MINUS exp %prec UMINUS                                   (A.OpExp {left = A.IntExp 0
                                                                        , oper = A.MinusOp
                                                                        , right = exp
                                                                        , pos = MINUSleft})

optionalexp : exp                                              (exp)
            |                                                  (A.NilExp)

explist :                                                      ([])
        | exp                                                  ([exp])
        | explist COMMA exp                                    (explist @ [exp])
 
lvalue : ID                                                    (A.SimpleVar(S.symbol ID, IDleft))
       | lvalue DOT ID                                         (A.FieldVar(lvalue, S.symbol ID, lvalueleft))
       | ID LBRACK exp RBRACK                                  (A.SubscriptVar (A.SimpleVar(S.symbol ID, IDleft)
                                                                               , exp, IDleft))
       | lvalue LBRACK exp RBRACK                              (A.SubscriptVar(lvalue, exp, lvalueleft))

decs :                                                         ([])
     | decs dec                                                (decs @ [dec])

dec : tydec                                                    (tydec)
    | vardec                                                   (vardec)
    | fundec                                                   (fundec)

ty : ID                                                        (A.NameTy (S.symbol ID, IDleft))
   | LBRACE tyfields RBRACE                                    (A.RecordTy tyfields)
   | ARRAY OF ID                                               (A.ArrayTy (S.symbol ID, IDleft))

tyfields :                                                     ()
         | ID COLON ID                                         ({name = S.symbol ID1
                                                                , escape = ref true
                                                                , typ = symbol ID2
                                                                , pos = ID1left})
         | ID COLON ID COMMA tyfields                          ({name = S.symbol ID1
                                                                , typ = S.symbol ID2
                                                                , escape = ref true
                                                                , pos = ID1left} :: tyfields)

tydec : TYPE ID EQ ty                                          (A.TypeDec {name: S.symbol ID
                                                                          , ty: ty
                                                                          , pos: TYPEleft})

vardec : VAR ID ASSIGN exp                                     (A.VarDec {name: S.symbol ID
                                                                         , escape: ref true
                                                                         , typ: NONE
                                                                         , init: exp
                                                                         , pos: VARleft})
       | VAR ID COLON ID ASSIGN exp                            (A.VarDec {name: S.symbol ID1
                                                                         , escape: ref true
                                                                         , typ: SOME (S.symbol ID2, ID2left)
                                                                         , init: exp
                                                                         , pos: VARleft})

fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp             (A.FunctionDec {name = S.symbol ID
                                                                              , params = tyfields
                                                                              , result = NONE
                                                                              , body = exp
                                                                              , pos = FUNCTIONleft})
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp    (A.FunctionDec {name = S.symbol ID1
                                                                              , params = tyfields
                                                                              , result = SOME (S.symbol ID2, ID2left)
                                                                              , body = exp
                                                                              , pos = FUNCTIONleft})
        
arithmetic : exp PLUS exp                                      (A.OpExp {left=exp1
                                                                        , oper=A.PlusOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp MINUS exp                                     (A.OpExp {left=exp1
                                                                        , oper=A.MinusOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp TIMES exp                                     (A.OpExp {left=exp1
                                                                        , oper=A.TimesOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp DIVIDE exp                                    (A.OpExp {left=exp1
                                                                        , oper=A.DivideOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
  
comparison : exp EQ exp                                        (A.OpExp {left=exp1
                                                                        , oper=A.EqOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp NEQ exp                                       (A.OpExp {left=exp1
                                                                        , oper=A.NeqOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp LT exp                                        (A.OpExp {left=exp1
                                                                        , oper=A.LtOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp LE exp                                        (A.OpExp {left=exp1
                                                                        , oper=A.LeOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp GT exp                                        (A.OpExp {left=exp1
                                                                        , oper=A.GtOp
                                                                        , right=exp2
                                                                        , pos=exp1left})
           | exp GE exp                                        (A.OpExp {left=exp1
                                                                        , oper=A.GeOp
                                                                        , right=exp2
                                                                        , pos=exp1left})

functioncall : ID LPAREN explist RPAREN                        (A.CallExp {func=symbol ID, args=explist, pos=IDleft})

